Q1) class Solution:
    def reverseArray(self, arr):
        l = 0
        r = len(arr) - 1

        while l < r:
            arr[l], arr[r] = arr[r], arr[l]
            l += 1
            r -= 1



Q2 class Solution:
    def getMinMax(self, arr):
        mn = arr[0]
        mx = arr[0]

        for x in arr:
            if x < mn:
                mn = x
            if x > mx:
                mx = x

        return [mn, mx]



Q3 class Solution:
    def kthSmallest(self, arr, k):
        freq = [0] * (100001)

        # freq count 
        for num in arr:
            freq[num] += 1

        count = 0
        for i in range(100001):
            count += freq[i]
            if count >= k:
                return i



Q4. class Solution:    
    def findUnion(self, a, b):
        freq = [0] * 100001
        result = []

        # process array a
        for x in a:
            if freq[x] == 0:
                freq[x] = 1
                result.append(x)

        # process array b
        for x in b:
            if freq[x] == 0:
                freq[x] = 1
                result.append(x)

        return result


Q5 class Solution:
    def largest(self, arr):
        mx = arr[0]         

        for x in arr:
            if x > mx:
                mx = x

        return mx



Q6 class Solution:
    def rotate(self, arr):
        n = len(arr)

        last = arr[n - 1]

       
        for i in range(n - 1, 0, -1):
            arr[i] = arr[i - 1]

       
        arr[0] = last


Q7 class Solution:
    def maxSubarraySum(self, arr):
        curr_sum = arr[0]
        max_sum = arr[0]

        for i in range(1, len(arr)):
            # either start new subarray OR extend previous
            curr_sum = max(arr[i], curr_sum + arr[i])
            max_sum = max(max_sum, curr_sum)

        return max_sum


Q8 class Solution:
    def searchInsert(self, nums, target):
        low = 0
        high = len(nums) - 1

        while low <= high:   # âœ… MUST be <=
            mid = (low + high) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                low = mid + 1
            else:
                high = mid - 1

        return low



Q 9 class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # store value with original index
        arr = []
        for i in range(len(nums)):
            arr.append((nums[i], i))

        # sort based on values
        arr.sort()

        left = 0
        right = len(arr) - 1

        while left < right:
            curr_sum = arr[left][0] + arr[right][0]

            if curr_sum == target:
                return [arr[left][1], arr[right][1]]
            elif curr_sum < target:
                left += 1
            else:
                right -= 1






Q10 class Solution:
    def minJumps(self, arr):
        n = len(arr)

        # If first element is 0, we cannot move anywhere
        if arr[0] == 0:
            return -1

        # Initialization
        maxReach = arr[0]
        steps = arr[0]
        jumps = 1

        for i in range(1, n):
            # If we have reached the end
            if i == n - 1:
                return jumps

            # Update maxReach
            maxReach = max(maxReach, i + arr[i])

            # Use a step
            steps -= 1

            # If no steps left
            if steps == 0:
                jumps += 1

                # If current index is beyond maxReach, cannot move
                if i >= maxReach:
                    return -1

                # Reinitialize steps
                steps = maxReach - i

        return -1
